## Fixed Python Script (`report_processor.py`)

```python
import re
from pathlib import Path
import sys

def parse_report_to_html(txt_file_path, output_html_path):
    try:
        print(f"Processing: {txt_file_path}")
        
        with open(txt_file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        print("Original content:")
        print("=" * 50)
        print(content)
        print("=" * 50)
        
        # More flexible section splitting
        sections = re.split(r'SECTION-I\s*:|Section-II\s*:|SECTION-II\s*:', content, flags=re.IGNORECASE)
        
        print(f"Found {len(sections)} sections after split")
        
        if len(sections) < 3:
            # Try alternative splitting method
            print("Trying alternative parsing method...")
            return parse_report_alternative(content, output_html_path)
        
        # Extract header and sections
        header = sections[0].strip()
        section1 = sections[1].strip()
        section2 = sections[2].strip()
        
        print(f"Header: '{header}'")
        print(f"Section1 length: {len(section1)}")
        print(f"Section2 length: {len(section2)}")
        
        section1_data = parse_section1(section1)
        total_targets, table_data, time_taken = parse_section2(section2)
        
        html_output = generate_html(header, section1_data, total_targets, table_data, time_taken)
        
        with open(output_html_path, 'w', encoding='utf-8') as f:
            f.write(html_output)
        
        print(f"✓ Successfully created: {output_html_path}")
        return 0
        
    except Exception as e:
        print(f"❌ Error processing {txt_file_path}: {str(e)}")
        # Create error HTML
        error_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Processing Error</title>
            <style>
                body {{ font-family: Arial, sans-serif; padding: 20px; color: #d63031; }}
                .error {{ background: #ffeaa7; padding: 20px; border-radius: 5px; }}
            </style>
        </head>
        <body>
            <div class="error">
                <h2>Error Processing Report</h2>
                <p><strong>File:</strong> {Path(txt_file_path).name}</p>
                <p><strong>Error:</strong> {str(e)}</p>
            </div>
        </body>
        </html>
        """
        with open(output_html_path, 'w', encoding='utf-8') as f:
            f.write(error_html)
        return 1

def parse_report_alternative(content, output_html_path):
    """Alternative parsing method for different report formats"""
    try:
        print("Using alternative parsing method...")
        
        # Extract header (everything before SECTION-I)
        header_match = re.search(r'^(.+?)(?=SECTION-I)', content, re.DOTALL | re.IGNORECASE)
        header = header_match.group(1).strip() if header_match else "OUTPUT OF AI-BASED TARGET DETECTION"
        
        # Extract Section I
        section1_match = re.search(r'SECTION-I\s*:(.+?)(?=Section-II|SECTION-II)', content, re.DOTALL | re.IGNORECASE)
        if not section1_match:
            section1_match = re.search(r'SECTION-I\s*:(.+?)(?=Total number|TARGET CATEGORY)', content, re.DOTALL | re.IGNORECASE)
        
        section1 = section1_match.group(1).strip() if section1_match else ""
        
        # Extract Section II
        section2_match = re.search(r'Section-II\s*:(.+?)(?=Time taken for)', content, re.DOTALL | re.IGNORECASE)
        if not section2_match:
            section2_match = re.search(r'SECTION-II\s*:(.+?)(?=Time taken for)', content, re.DOTALL | re.IGNORECASE)
        if not section2_match:
            # If we can't find the end, take everything after Section-II
            section2_match = re.search(r'Section-II\s*:(.+)', content, re.DOTALL | re.IGNORECASE)
        
        section2 = section2_match.group(1).strip() if section2_match else ""
        
        print(f"Alternative parse - Header: '{header}'")
        print(f"Alternative parse - Section1: '{section1[:100]}...'")
        print(f"Alternative parse - Section2: '{section2[:100]}...'")
        
        section1_data = parse_section1(section1)
        total_targets, table_data, time_taken = parse_section2(section2)
        
        html_output = generate_html(header, section1_data, total_targets, table_data, time_taken)
        
        with open(output_html_path, 'w', encoding='utf-8') as f:
            f.write(html_output)
        
        print(f"✓ Alternative method succeeded: {output_html_path}")
        return 0
        
    except Exception as e:
        print(f"❌ Alternative parsing also failed: {str(e)}")
        return 1

def parse_section1(section1_content):
    """Parse Section I with key-value pairs"""
    section1_data = []
    
    if not section1_content:
        return section1_data
        
    lines = section1_content.split('\n')
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        if ':' in line:
            key, value = line.split(':', 1)
            key = key.strip()
            value = value.strip()
            if key and value:
                section1_data.append({'key': key, 'value': value})
    
    print(f"Parsed {len(section1_data)} items from Section I")
    return section1_data

def parse_section2(section2_content):
    """Parse Section II with dynamic target categories and entries"""
    total_targets = 0
    table_data = []
    time_taken = ""
    
    if not section2_content:
        return total_targets, table_data, time_taken
    
    # Find total targets - handle no space after section header
    total_match = re.search(r'Total number of targets detected in this image are\s*(\d+)', section2_content)
    if total_match:
        total_targets = int(total_match.group(1))
    
    # Find time taken
    time_match = re.search(r'Time taken for.*?\(hrs:min:sec\)', section2_content)
    if time_match:
        time_taken = time_match.group(0)
    
    # Parse the target table
    lines = section2_content.split('\n')
    current_category = None
    in_table_section = False
    
    for line in lines:
        line = line.rstrip()
        
        # Skip empty lines
        if not line.strip():
            continue
            
        # Look for table header
        if 'TARGET CATEGORY' in line and 'TARGET NAME' in line and 'TARGET COUNT' in line:
            in_table_section = True
            continue
            
        # Stop if we hit time taken
        if 'Time taken for' in line:
            break
            
        if in_table_section:
            # Check for category lines (text ending with colon)
            if re.search(r'[A-Za-z][A-Za-z\s]+:$', line.strip()):
                current_category = line.strip()[:-1]  # Remove trailing colon
            elif current_category and line.strip():
                # This is a target entry
                target_entry = parse_target_line(line)
                if target_entry:
                    table_data.append({
                        'category': current_category,
                        'name': target_entry['name'],
                        'count': target_entry['count']
                    })
    
    print(f"Parsed {len(table_data)} targets from Section II")
    return total_targets, table_data, time_taken

def parse_target_line(line):
    """Parse individual target lines with flexible formatting"""
    line = line.strip()
    
    # Remove any leading colons or spaces
    line = re.sub(r'^\s*:\s*', '', line)
    
    # Handle the specific format from the example
    if re.match(r'^[A-Za-z\-]+\s+[A-Za-z0-9\-]+$', line):
        parts = line.split()
        if len(parts) >= 2:
            return {'name': parts[0], 'count': parts[1]}
    
    # Split by multiple spaces
    parts = re.split(r'\s{2,}', line)
    
    if len(parts) >= 2:
        name = parts[0].strip()
        count = parts[1].strip()
    elif len(parts) == 1:
        name = parts[0].strip()
        count = '1'  # Default count
    else:
        return None
        
    # Validate count is numeric
    if not re.match(r'^\d+$', count):
        count = '1'
    
    return {'name': name, 'count': count}

def generate_html(header, section1_data, total_targets, table_data, time_taken):
    # Build section 1 HTML
    section1_html = ""
    for item in section1_data:
        section1_html += f"""
        <div class="info-row">
            <div class="info-key">{item['key']}</div>
            <div class="info-separator">:</div>
            <div class="info-value">{item['value']}</div>
        </div>"""
    
    # If no section1 data, create placeholder
    if not section1_html:
        section1_html = """
        <div class="info-row">
            <div class="info-key">No image information available</div>
        </div>"""
    
    # Build table HTML
    table_html = ""
    if table_data:
        table_rows = ""
        for item in table_data:
            table_rows += f"""
            <tr>
                <td class="category-cell">{item['category']}</td>
                <td class="name-cell">{item['name']}</td>
                <td class="count-cell">{item['count']}</td>
            </tr>"""
        
        table_html = f"""
        <table class="modern-table">
            <thead>
                <tr>
                    <th>TARGET CATEGORY</th>
                    <th>TARGET NAME</th>
                    <th>TARGET COUNT</th>
                </tr>
            </thead>
            <tbody>
                {table_rows}
            </tbody>
        </table>"""
    else:
        table_html = """
        <div class="empty-table">
            <p>No target data available or unable to parse target information</p>
            <p>Please check the original report format</p>
        </div>"""
    
    return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Target Detection Report</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }}
        
        .report-container {{
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }}
        
        .report-header {{
            background: #2c3e50;
            color: white;
            padding: 25px;
            text-align: center;
            border-bottom: 3px solid #3498db;
        }}
        
        .report-header h1 {{
            font-size: 1.4em;
            font-weight: 400;
            font-family: 'Courier New', monospace;
            white-space: pre;
            margin: 0;
        }}
        
        .section {{
            padding: 25px;
            border-bottom: 1px solid #e9ecef;
        }}
        
        .section:last-child {{
            border-bottom: none;
        }}
        
        .section-title {{
            color: #2c3e50;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 8px;
            border-bottom: 2px solid #3498db;
        }}
        
        .info-container {{
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
        }}
        
        .info-row {{
            display: table-row;
            margin-bottom: 5px;
        }}
        
        .info-key {{
            display: table-cell;
            font-weight: 600;
            color: #495057;
            padding: 4px 8px 4px 0;
            white-space: pre;
            min-width: 220px;
        }}
        
        .info-separator {{
            display: table-cell;
            padding: 4px 5px 4px 0;
            color: #6c757d;
        }}
        
        .info-value {{
            display: table-cell;
            color: #212529;
            white-space: pre;
            padding: 4px 0;
        }}
        
        .total-targets {{
            background: #e8f5e8;
            border: 1px solid #28a745;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #155724;
            font-weight: 500;
            font-size: 1.1em;
        }}
        
        .table-container {{
            overflow-x: auto;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            margin-top: 15px;
        }}
        
        .modern-table {{
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
            min-width: 600px;
        }}
        
        .modern-table thead {{
            background: #343a40;
            color: white;
        }}
        
        .modern-table th {{
            padding: 15px 12px;
            text-align: left;
            font-weight: 500;
            border: none;
        }}
        
        .modern-table td {{
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
        }}
        
        .modern-table tbody tr:hover {{
            background: #f8f9fa;
        }}
        
        .category-cell {{
            font-weight: 600;
            color: #e74c3c;
            font-family: 'Courier New', monospace;
            white-space: pre;
        }}
        
        .name-cell {{
            color: #2980b9;
            font-family: 'Courier New', monospace;
            white-space: pre;
        }}
        
        .count-cell {{
            text-align: center;
            font-weight: 600;
            color: #f39c12;
            font-family: 'Courier New', monospace;
        }}
        
        .empty-table {{
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
            background: #f8f9fa;
        }}
        
        .report-footer {{
            background: #e9ecef;
            padding: 15px 25px;
            text-align: center;
            color: #495057;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }}
        
        @media (max-width: 768px) {{
            body {{
                padding: 10px;
            }}
            
            .section {{
                padding: 20px;
            }}
            
            .report-header {{
                padding: 20px;
            }}
            
            .report-header h1 {{
                font-size: 1.1em;
                white-space: pre-wrap;
            }}
            
            .info-key {{
                min-width: 150px;
            }}
            
            .modern-table {{
                font-size: 0.85em;
            }}
            
            .modern-table th,
            .modern-table td {{
                padding: 8px 10px;
            }}
        }}
    </style>
</head>
<body>
    <div class="report-container">
        <div class="report-header">
            <h1>{header}</h1>
        </div>
        
        <div class="section">
            <h2 class="section-title">SECTION-I: IMAGE INFO</h2>
            <div class="info-container">
                {section1_html}
            </div>
        </div>
        
        <div class="section">
            <h2 class="section-title">SECTION-II: TARGET DETECTIONS</h2>
            
            <div class="total-targets">
                Total number of targets detected in this image are {total_targets}
            </div>
            
            <div class="table-container">
                {table_html}
            </div>
        </div>
        
        <div class="report-footer">
            {time_taken if time_taken else "Time information not available"}
        </div>
    </div>
</body>
</html>"""

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python report_processor.py <input_txt> <output_html>")
        print("Example: python report_processor.py report.txt report.html")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    # Check if input file exists
    if not Path(input_file).exists():
        print(f"❌ Input file not found: {input_file}")
        sys.exit(1)
    
    result = parse_report_to_html(input_file, output_file)
    sys.exit(result)
```

## Key Fixes:

1. **Better Section Parsing**: Uses `\s*` to handle variable whitespace in section headers
2. **Alternative Parsing Method**: Falls back to regex-based parsing if initial split fails
3. **Debug Output**: Shows exactly what's being parsed to help diagnose issues
4. **Handles No Space After Section Headers**: Specifically handles your case where there's no space between "Section-II:" and "Total number..."
5. **Better Error Handling**: Creates descriptive error HTML pages when parsing fails
6. **Flexible Target Parsing**: Multiple methods to parse target lines

## Test with this sample report format:

Create a test file `test_report.txt`:

Run: `python report_processor.py test_report.txt test_report.html`

The debug output will show you exactly what's being parsed and help identify any remaining formatting issues with your specific reports.
